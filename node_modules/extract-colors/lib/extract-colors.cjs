"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function t({pixels:t=64e3,distance:s=.22,colorValidator:e=(t,s,e,o)=>(o??255)>250,hueDistance:o=.08333333333333333,saturationDistance:r=.2,lightnessDistance:n=.2,crossOrigin:i="",requestMode:a="cors"}={}){const c=(t,s,e=0,o=Number.MAX_VALUE)=>{if(Number(s)!==s)throw new Error(`${t} is not a valid number (${s})`);return s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>o&&console.warn(`${t} can not be more than ${o} (it's ${s})`),Math.min(Math.max(s,e),o)},h=(t,s,e)=>{e.indexOf(s)<0&&console.warn(`${t} can be one of this values ${e.map((t=>`"${t}"`)).join(", ")} (it's "${s}")`)};((t,s,e=0,o=Number.MAX_SAFE_INTEGER)=>{if(!Number.isInteger(s))throw new Error(`${t} is not a valid number (${s})`);s<e&&console.warn(`${t} can not be less than ${e} (it's ${s})`),s>o&&console.warn(`${t} can not be more than ${o} (it's ${s})`),Math.min(Math.max(s,e),o)})("pixels",t||0,1),c("distance",s,0,1),((t,s)=>{if(!s||"[object Function]"!=={}.toString.call(s))throw new Error(`${t} is not a function (${s})`)})("colorValidator",e),c("hueDistance",o,0,1),c("saturationDistance",r,0,1),c("lightnessDistance",n,0,1),h("crossOrigin",i,["","anonymous","use-credentials"]),h("requestMode",a,["cors","navigate","no-cors","same-origin"])}const s=({pixels:t=64e3,distance:s=.22,colorValidator:e=(t,s,e,o)=>(o??255)>250,hueDistance:o=.08333333333333333,saturationDistance:r=.2,lightnessDistance:n=.2,crossOrigin:i="",requestMode:a="cors"}={})=>[Math.max(t,1),Math.min(Math.max(s,0),1),e,Math.min(Math.max(o,0),1),Math.min(Math.max(r,0),1),Math.min(Math.max(n,0),1),i,a];class e{constructor(t,s,e,o=t<<16|s<<8|e){this.t=1,this.o=-1,this.i=-1,this.h=-1,this.u=-1,this.l=t,this._=s,this.m=e,this.M=o}static distance(t,s){return(Math.abs(s.l-t.l)+Math.abs(s._-t._)+Math.abs(s.m-t.m))/765}clone(){const t=new e(this.l,this._,this.m,this.M);return t.t=this.t,t}p(){const t=this.l/255,s=this._/255,e=this.m/255,o=Math.max(t,s,e),r=Math.min(t,s,e);if(this.h=(o+r)/2,o===r)this.i=0,this.o=0,this.u=0;else{const n=o-r;switch(this.o=this.h>.5?n/(2-o-r):n/(o+r),this.u=this.o*(2*(.5-Math.abs(.5-this.h))),o){case t:this.i=((s-e)/n+(s<e?6:0))/6;break;case s:this.i=((e-t)/n+2)/6;break;case e:this.i=((t-s)/n+4)/6}}}get D(){return-1===this.i&&this.p(),this.i}get $(){return-1===this.o&&this.p(),this.o}get C(){return-1===this.h&&this.p(),this.h}get V(){return-1===this.u&&this.p(),this.u}}class o{constructor(){this.t=0,this.v={}}j(t,s,o,r){return this.t++,this.v[t]?this.v[t].t++:this.v[t]=new e(s,o,r,t),this.v[t]}I(){return Object.keys(this.v).map((t=>this.v[t]))}O(){const t=this.I().reduce(((t,s)=>t.t>=s.t?t:s)).clone();return t.t=this.t,t}}class r{constructor(){this.t=0,this.v={}}I(){return Object.keys(this.v).map((t=>this.v[t]))}j(t,s,e){const o=t<<16|s<<8|e,r=(t>>4&15)<<8|(s>>4&15)<<4|e>>4&15;return this.t++,this.N(r).j(o,t,s,e)}N(t){return this.v[t]||(this.v[t]=new o),this.v[t]}L(t){const s=this.I().map((t=>t.O()));s.sort(((t,s)=>s.t-t.t));const o=[];for(;s.length;){const r=s.shift();s.filter((s=>e.distance(r,s)<t)).forEach((t=>{r.t+=t.t;const e=s.findIndex((s=>s===t));s.splice(e,1)})),o.push(r)}return o}}const n=({data:t,width:s,height:e},o,n,i)=>{const a=new r,c=s&&e&&Math.floor(s*e/o)||1;let h=0;for(let r=0;r<t.length;r+=4*c){const s=t[r],e=t[r+1],o=t[r+2];i(s,e,o,t[r+3])?a.j(s,e,o):h++}return{S:a.L(n),count:a.t+h}},i=(t,s)=>Math.abs(t-s);class a{constructor(){this.S=[],this.k=null}j(t){this.S.push(t),this.k=null}q(t,s,e,o){for(const a of this.S){if(!(r=a.D,n=t.D,Math.min(i(r,n),i((r+.5)%1,(n+.5)%1))<s&&i(a.$,t.$)<e&&i(a.C,t.C)<o))return!1}var r,n;return!0}get H(){if(!this.k){const{r:t,g:s,b:o}=this.S.reduce(((t,s)=>(t.r+=s.l,t.g+=s._,t.b+=s.m,t)),{r:0,g:0,b:0}),r=this.S.reduce(((t,s)=>t+s.t),0);this.k=new e(Math.round(t/this.S.length),Math.round(s/this.S.length),Math.round(o/this.S.length)),this.k.t=r}return this.k}}class c{constructor(t,s,e){this.P=[],this.D=t,this.$=s,this.C=e}j(t){const s=this.P.find((s=>s.q(t,this.D,this.$,this.C)));if(s)s.j(t);else{const s=new a;s.j(t),this.P.push(s)}}F(){return this.P.map((t=>t.H))}}const h=()=>"object"==typeof self&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name,u=()=>"undefined"==typeof window&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node,l=(t,s,e,o,r)=>{const n=((t,s,e,o,r)=>{const n=new c(e,o,r);t.forEach((t=>n.j(t)));const i=n.F();return i.sort(((t,e)=>(e.V+.1)*(.9-e.t/s)-(t.V+.1)*(.9-t.t/s))),i})(t,s,e,o,r);return n.map((t=>((t,s)=>({hex:`#${"0".repeat(6-t.M.toString(16).length)}${t.M.toString(16)}`,red:t.l,green:t._,blue:t.m,area:t.t/s,hue:t.D,saturation:t.$,lightness:t.C,intensity:t.V}))(t,s)))},d=(t,s)=>{const e=t.width*t.height,o=e<s?t.width:Math.round(t.width*Math.sqrt(s/e)),r=e<s?t.height:Math.round(t.height*Math.sqrt(s/e)),n=((t,s)=>{if(h())return new OffscreenCanvas(t,s);const e=document.createElement("canvas");return e.width=t,e.height=s,e})(o,r).getContext("2d");return n.drawImage(t,0,0,t.width,t.height,0,0,o,r),n.getImageData(0,0,o,r)},f=(e,o={})=>{process.env.NODE_ENV !== "production"&&t(o);const[r,i,a,c,h,u]=s(o),{S:d,count:f}=n(e,r,i,a);return l(d,f,c,h,u)},_=async(e,o={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Use extractColors instead extractColorsFromImage for Node.js");return[]}process.env.NODE_ENV !== "production"&&t(o);const[r,i,a,c,h,f,_]=s(o);return e.crossOrigin=_,new Promise((t=>{const s=s=>{const e=d(s,r),{S:o,count:u}=n(e,r,i,a);t(l(o,u,c,h,f))};if(e.complete)s(e);else{const t=()=>{e.removeEventListener("load",t),s(e)};e.addEventListener("load",t)}}))},g=async(e,o={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Use extractColors instead extractColorsFromImageBitmap for Node.js");return[]}process.env.NODE_ENV !== "production"&&t(o);const[r,i,a,c,h,f]=s(o),_=d(e,r),{S:g,count:w}=n(_,r,i,a);return l(g,w,c,h,f)},w=async(e,o={})=>{if(u()){if(process.env.NODE_ENV !== "production")throw new Error("Can not use extractColorsFromSrc for Node.js");return[]}if(process.env.NODE_ENV !== "production"&&t(o),h()){const t=s(o),r=await fetch(e,{mode:t[7]}),n=await r.blob(),i=await createImageBitmap(n),a=await g(i,o);return i.close(),a}const r=new Image;return r.src=e,_(r,o)};exports.extractColors=(t,s)=>{if("undefined"!=typeof window&&void 0!==window.document){if(process.env.NODE_ENV !== "production"&&(null==s?void 0:s.requestMode)&&console.warn("options.requestMode not supported in Browser, use options.crossOrigin instead"),t instanceof Image)return _(t,s);if(t instanceof ImageData||t instanceof Object&&t.data)return new Promise((e=>{e(f(t,s))}));if("string"==typeof t)return w(t,s)}if(h()){if(process.env.NODE_ENV !== "production"&&(null==s?void 0:s.crossOrigin)&&console.warn("options.crossOrigin not supported in Web Worker, use options.requestMode instead"),t instanceof ImageData||t instanceof Object&&t.data)return new Promise((e=>{e(f(t,s))}));if("string"==typeof t)return w(t,s);if(t.src)return process.env.NODE_ENV !== "production"&&console.warn("HTMLImageElement not enable on worker, a fallback is used to extract src from your HTMLImageElement, please send 'src' instead HTMLImageElement"),w(t.src,s)}if(u()){if(process.env.NODE_ENV !== "production"){if(t instanceof String)throw new Error("Send imageData to extractColors (Image src or HTMLImageElement not supported in Nodejs)");if(!t.data)throw new Error("Send imageData to extractColors");(null==s?void 0:s.crossOrigin)&&console.warn("options.crossOrigin not supported in Node.js")}return new Promise((e=>{e(f(t,s))}))}throw new Error("Can not analyse picture")},exports.extractColorsFromImage=_,exports.extractColorsFromImageBitmap=g,exports.extractColorsFromImageData=f,exports.extractColorsFromSrc=w;
//# sourceMappingURL=extract-colors.cjs.map
