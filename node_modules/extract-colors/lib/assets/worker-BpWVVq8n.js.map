{"version":3,"file":"worker-BpWVVq8n.js","sources":["../src/color/Color.ts","../src/sort/AverageGroup.ts","../src/sort/AverageManager.ts","../src/color/LeafGroup.ts","../src/color/RootGroup.ts","../src/extract/extractor.ts","../src/worker.ts","../src/sort/sortColors.ts","../src/color/FinalColor.ts"],"sourcesContent":["/**\n * Informations like saturation or count of pixels in image.\n *\n * @class\n * @classdesc Calculate some informations and store data about color.\n */\nexport default class Color {\n  _red: number;\n  _green: number;\n  _blue: number;\n  _hex: number;\n  _count = 1;\n\n  private __saturation = -1;\n  private __hue = -1;\n  private __lightness = -1;\n  private __intensity = -1;\n\n  /**\n   * Set red, green and blue colors to create the Color object.\n   */\n  constructor(\n    red: number,\n    green: number,\n    blue: number,\n    hex = (red << 16) | (green << 8) | blue\n  ) {\n    this._red = red;\n    this._green = green;\n    this._blue = blue;\n    this._hex = hex;\n  }\n\n  /**\n   * Distance between two colors.\n   * - Minimum is 0 (between two same colors)\n   * - Maximum is 1 (for example between black and white)\n   */\n  static distance(colorA: Color, colorB: Color) {\n    return (\n      (Math.abs(colorB._red - colorA._red) +\n        Math.abs(colorB._green - colorA._green) +\n        Math.abs(colorB._blue - colorA._blue)) /\n      (3 * 0xff)\n    );\n  }\n\n  clone() {\n    const color = new Color(this._red, this._green, this._blue, this._hex);\n    color._count = this._count;\n    return color;\n  }\n\n  updateHSL() {\n    const red = this._red / 255;\n    const green = this._green / 255;\n    const blue = this._blue / 255;\n\n    const max = Math.max(red, green, blue);\n    const min = Math.min(red, green, blue);\n\n    this.__lightness = (max + min) / 2;\n\n    // achromatic\n    if (max === min) {\n      this.__hue = 0;\n      this.__saturation = 0;\n      this.__intensity = 0;\n    } else {\n      const distance = max - min;\n\n      this.__saturation =\n        this.__lightness > 0.5\n          ? distance / (2 - max - min)\n          : distance / (max + min);\n      this.__intensity =\n        this.__saturation * ((0.5 - Math.abs(0.5 - this.__lightness)) * 2);\n      switch (max) {\n        case red:\n          this.__hue = ((green - blue) / distance + (green < blue ? 6 : 0)) / 6;\n          break;\n        case green:\n          this.__hue = ((blue - red) / distance + 2) / 6;\n          break;\n        case blue:\n          this.__hue = ((red - green) / distance + 4) / 6;\n          break;\n      }\n    }\n  }\n\n  /**\n   * Hue from 0 to 1\n   */\n  get _hue() {\n    if (this.__hue === -1) {\n      this.updateHSL();\n    }\n    return this.__hue;\n  }\n\n  /**\n   * Saturation from 0 to 1\n   */\n  get _saturation() {\n    if (this.__saturation === -1) {\n      this.updateHSL();\n    }\n    return this.__saturation;\n  }\n\n  /**\n   * Lightness from 0 to 1\n   */\n  get _lightness() {\n    if (this.__lightness === -1) {\n      this.updateHSL();\n    }\n    return this.__lightness;\n  }\n\n  /**\n   * Color intensity from 0 to 1\n   */\n  get _intensity() {\n    if (this.__intensity === -1) {\n      this.updateHSL();\n    }\n    return this.__intensity;\n  }\n}\n","import Color from \"../color/Color\";\n\nconst distance = (a: number, b: number) => Math.abs(a - b);\nconst hueDistance = (a: number, b: number) =>\n  Math.min(distance(a, b), distance((a + 0.5) % 1, (b + 0.5) % 1));\n\nexport class AverageGroup {\n  colors: Color[] = [];\n  private _average: Color | null = null;\n\n  addColor(color: Color) {\n    this.colors.push(color);\n    this._average = null;\n  }\n\n  isSamePalette(\n    color: Color,\n    hue: number,\n    saturation: number,\n    lightness: number\n  ) {\n    for (const currentColor of this.colors) {\n      const isSame =\n        hueDistance(currentColor._hue, color._hue) < hue &&\n        distance(currentColor._saturation, color._saturation) < saturation &&\n        distance(currentColor._lightness, color._lightness) < lightness;\n\n      if (!isSame) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  get average() {\n    if (!this._average) {\n      const { r, g, b } = this.colors.reduce(\n        (total, color) => {\n          total.r += color._red;\n          total.g += color._green;\n          total.b += color._blue;\n          return total;\n        },\n        { r: 0, g: 0, b: 0 }\n      );\n\n      const total = this.colors.reduce(\n        (_count, color) => _count + color._count,\n        0\n      );\n      this._average = new Color(\n        Math.round(r / this.colors.length),\n        Math.round(g / this.colors.length),\n        Math.round(b / this.colors.length)\n      );\n      this._average._count = total;\n    }\n    return this._average;\n  }\n}\n","import Color from \"../color/Color\";\nimport { AverageGroup } from \"./AverageGroup\";\n\nexport class AverageManager {\n  _hue: number;\n  _saturation: number;\n  _lightness: number;\n\n  private _groups: AverageGroup[] = [];\n\n  constructor(hue: number, saturation: number, lightness: number) {\n    this._hue = hue;\n    this._saturation = saturation;\n    this._lightness = lightness;\n  }\n\n  addColor(color: Color) {\n    const samePalette = this._groups.find((averageGroup) =>\n      averageGroup.isSamePalette(\n        color,\n        this._hue,\n        this._saturation,\n        this._lightness\n      )\n    );\n    if (samePalette) {\n      samePalette.addColor(color);\n    } else {\n      const averageGroup = new AverageGroup();\n      averageGroup.addColor(color);\n      this._groups.push(averageGroup);\n    }\n  }\n\n  getGroups() {\n    return this._groups.map((averageGroup) => averageGroup.average);\n  }\n}\n","import Color from \"./Color\";\n\n/**\n * Manage list of colors to optimize and merge neighbors colors.\n *\n * @export\n * @class LeafGroup\n */\nexport default class LeafGroup {\n  _count: number;\n  _children: Record<number, Color>;\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor() {\n    this._count = 0;\n    this._children = {};\n  }\n\n  /**\n   * Add color to the group.\n   *\n   * @param _hex Hexadecimal value of the color\n   * @param _red Red chanel amount of the color\n   * @param _green Green chanel amount of the color\n   * @param _blue Blue chanel amount of the color\n   * @returns The color\n   */\n  addColor(_hex: number, _red: number, _green: number, _blue: number) {\n    this._count++;\n    if (this._children[_hex]) {\n      this._children[_hex]._count++;\n    } else {\n      this._children[_hex] = new Color(_red, _green, _blue, _hex);\n    }\n    return this._children[_hex];\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   *\n   * @returns List of colors\n   */\n  getList() {\n    return (Object.keys(this._children) as unknown[] as number[]).map(\n      (key) => this._children[key]\n    );\n  }\n\n  /**\n   * Representative color of leaf.\n   *\n   * @returns Main color of the leaf\n   */\n  createMainColor() {\n    const list = this.getList();\n    const biggest = list.reduce((a, b) => (a._count >= b._count ? a : b));\n    const main = biggest.clone();\n    main._count = this._count;\n    return main;\n  }\n}\n","import Color from \"./Color\";\nimport LeafGroup from \"./LeafGroup\";\n\n/**\n * RootGroup colors with algorithms to optimize and merge neighbors colors.\n *\n * @class\n * @classdesc Manage list of colors or groups.\n */\nexport default class RootGroup {\n  _count: number;\n  _children: Record<number, LeafGroup>;\n\n  /**\n   * Store colors or groups and _count similiar groups in the image.\n   */\n  constructor() {\n    this._count = 0;\n    this._children = {};\n  }\n\n  /**\n   * Get list of groups of list of colors.\n   */\n  getList() {\n    return (Object.keys(this._children) as unknown[] as number[]).map(\n      (key) => this._children[key]\n    );\n  }\n\n  addColor(r: number, g: number, b: number) {\n    const full = (r << 16) | (g << 8) | b;\n    const loss =\n      (((r >> 4) & 0xf) << 8) | (((g >> 4) & 0xf) << 4) | ((b >> 4) & 0xf);\n    this._count++;\n    return this.getLeafGroup(loss).addColor(full, r, g, b);\n  }\n\n  /**\n   * Add a key for a color, this key is a simplification to find neighboring colors.\n   * Neighboring colors has same key.\n   */\n  getLeafGroup(key: number) {\n    if (!this._children[key]) {\n      this._children[key] = new LeafGroup();\n    }\n    return this._children[key] as LeafGroup;\n  }\n\n  /**\n   * List of colors sorted by importance (neighboring hare calculated by distance and removed).\n   * Importance is calculated with the saturation and _count of neighboring colors.\n   */\n  getColors(_distance: number) {\n    const list = this.getList().map((child) => child.createMainColor());\n\n    list.sort((a, b) => b._count - a._count);\n\n    const newList: Color[] = [];\n    while (list.length) {\n      const current = list.shift() as Color;\n      list\n        .filter((color) => Color.distance(current, color) < _distance)\n        .forEach((near) => {\n          current._count += near._count;\n          const i = list.findIndex((color) => color === near);\n          list.splice(i, 1);\n        });\n\n      newList.push(current);\n    }\n\n    return newList;\n  }\n}\n","import RootGroup from \"../color/RootGroup\";\n\n/**\n * Run extract process and get list of colors.\n */\nexport default (\n  {\n    data,\n    width,\n    height,\n  }:\n    | ImageData\n    | { data: Uint8ClampedArray | number[]; width?: number; height?: number },\n  _pixels: number,\n  _distance: number,\n  _colorValidator: (\n    red: number,\n    green: number,\n    blue: number,\n    alpha: number\n  ) => boolean\n) => {\n  const colorGroup = new RootGroup();\n  const reducer =\n    width && height ? Math.floor((width * height) / _pixels) || 1 : 1;\n  let ignoredColorsCount = 0;\n\n  for (let i = 0; i < data.length; i += 4 * reducer) {\n    const r = data[i]; // 0 -> 255\n    const g = data[i + 1];\n    const b = data[i + 2];\n    const a = data[i + 3];\n\n    if (_colorValidator(r, g, b, a)) {\n      colorGroup.addColor(r, g, b);\n    } else {\n      ignoredColorsCount++;\n    }\n  }\n\n  return {\n    colors: colorGroup.getColors(_distance),\n    count: colorGroup._count + ignoredColorsCount,\n  };\n};\n","import Color from \"./color/Color\";\nimport sortColors from \"./sort/sortColors\";\nimport { createFinalColor } from \"./color/FinalColor\";\nimport type { ImageDataAlt, OptionsCleaned } from \"./types/Options\";\nimport extractor from \"./extract/extractor\";\nimport type { FinalColor } from \"./types/Color\";\n\n/**\n * Sort colors and generate standard list of colors.\n *\n * @param _colors List of colors\n * @param _pixels Count of pixels in the image\n * @param _hueDistance Maximal HUE distance between pixel before pixel merging\n * @param _saturationDistance Maximal saturation distance between pixel before pixel merging\n * @param _lightnessDistance Maximal lightness distance between pixel before pixel merging\n * @returns Sorted colors list\n */\nconst _sortFinalColors = (\n  _colors: Color[],\n  _pixels: number,\n  _hueDistance: number,\n  _saturationDistance: number,\n  _lightnessDistance: number\n) => {\n  const list = sortColors(\n    _colors,\n    _pixels,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n  return list.map((color) => createFinalColor(color, _pixels));\n};\n\n/**\n * Extract ImageData from image.\n * Reduce image to a pixel count.\n * Browser only\n *\n * @param _image HTML image element or Image Bitmap\n * @param _pixels Count of maximum pixels accepted for the calculation\n * @returns Data of the reduced image\n */\nconst _getImageData = (\n  _image: HTMLImageElement | ImageBitmap,\n  _pixels: number\n) => {\n  const currentPixels = _image.width * _image.height;\n  const width =\n    currentPixels < _pixels\n      ? _image.width\n      : Math.round(_image.width * Math.sqrt(_pixels / currentPixels));\n  const height =\n    currentPixels < _pixels\n      ? _image.height\n      : Math.round(_image.height * Math.sqrt(_pixels / currentPixels));\n\n  const canvas = new OffscreenCanvas(width, height);\n  const context = canvas.getContext(\"2d\") as OffscreenCanvasRenderingContext2D;\n  context.drawImage(\n    _image,\n    0,\n    0,\n    _image.width,\n    _image.height,\n    0,\n    0,\n    width,\n    height\n  );\n\n  return context.getImageData(0, 0, width, height);\n};\n\n/**\n * Extract colors from an ImageData object.\n *\n * @param imageData Data of the image\n * @param cleanOptions Process configuration options cleaned\n *\n * @returns List of extracted colors\n */\nconst _extractColorsFromImageData = (\n  imageData: ImageData | ImageDataAlt,\n  cleanOptions: OptionsCleaned\n) => {\n  const [\n    _pixels,\n    _distance,\n    _colorValidator,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance,\n  ] = cleanOptions;\n  const { colors, count } = extractor(\n    imageData,\n    _pixels,\n    _distance,\n    _colorValidator\n  );\n  return _sortFinalColors(\n    colors,\n    count,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n};\n\n/**\n * Extract colors from an ImageBitmap object.\n *\n * @param image image bitmap\n * @param cleanOptions Process configuration options cleaned\n *\n * @returns List of extracted colors\n */\nconst _extractColorsFromImageBitmap = async (\n  image: ImageBitmap,\n  cleanOptions: OptionsCleaned\n): Promise<FinalColor[]> => {\n  const [\n    _pixels,\n    _distance,\n    _colorValidator,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance,\n  ] = cleanOptions;\n\n  const imageData = _getImageData(image, _pixels);\n  const { colors, count } = extractor(\n    imageData,\n    _pixels,\n    _distance,\n    _colorValidator\n  );\n\n  return _sortFinalColors(\n    colors,\n    count,\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n};\n\n/**\n * Extract colors from a path.\n * The image will be downloaded.\n *\n * @param src Image source\n * @param cleanOptions Process configuration options cleaned\n *\n * @returns List of extracted colors\n */\nconst _extractColorsFromSrc = async (\n  src: string,\n  cleanOptions: OptionsCleaned\n): Promise<FinalColor[]> => {\n  const response = await fetch(src, { mode: cleanOptions[7] });\n  const blob = await response.blob();\n  const bitmap = await createImageBitmap(blob);\n  const colors = await _extractColorsFromImageBitmap(bitmap, cleanOptions);\n  bitmap.close();\n  return colors;\n};\n\n/**\n * Extract colors from a picture.\n *\n * @param picture image source or image data (node.js context only support image data)\n * @param cleanOptions Process configuration options cleaned\n * @param callback Function with list of extracted colors in first parameter\n */\nconst extractColors = async (\n  picture: string | ImageData | ImageDataAlt,\n  cleanOptions: OptionsCleaned,\n  callback: (list: FinalColor[]) => void\n) => {\n  if (\n    picture instanceof ImageData ||\n    (picture instanceof Object && (picture as ImageDataAlt).data)\n  ) {\n    return callback(\n      _extractColorsFromImageData(\n        picture as ImageData | ImageDataAlt,\n        cleanOptions\n      )\n    );\n  }\n\n  if (typeof picture === \"string\") {\n    return callback(await _extractColorsFromSrc(picture, cleanOptions));\n  }\n\n  throw new Error(`Can not analyse picture`);\n};\n\n// Listend and send data to Worker Wrapper\nonmessage = (message) => {\n  const [\n    picture,\n    [_pixels, _distance, _colorValidatorStr, ..._cleanInputsRest],\n  ] = message.data as Parameters<typeof extractColors>;\n  extractColors(\n    picture,\n    [\n      _pixels,\n      _distance,\n      Function(`return ${_colorValidatorStr}`)(),\n      ..._cleanInputsRest,\n    ],\n    postMessage\n  );\n};\n","import Color from \"../color/Color\";\nimport { AverageManager } from \"./AverageManager\";\n\nexport default (\n  list: Color[],\n  _pixels: number,\n  _hueDistance: number,\n  _saturationDistance: number,\n  _lightnessDistance: number\n) => {\n  const averageManager = new AverageManager(\n    _hueDistance,\n    _saturationDistance,\n    _lightnessDistance\n  );\n  list.forEach((color) => averageManager.addColor(color));\n\n  const sorted = averageManager.getGroups();\n\n  sorted.sort((a, b) => {\n    const bPower = (b._intensity + 0.1) * (0.9 - b._count / _pixels);\n    const aPower = (a._intensity + 0.1) * (0.9 - a._count / _pixels);\n    return bPower - aPower;\n  });\n  return sorted;\n};\n","import { FinalColor } from \"../types/Color\";\nimport Color from \"./Color\";\n\n/**\n * Normalize color\n *\n * @param color Initial color\n * @param pixels Pixel count of this color\n *\n * @returns Normalized color\n */\nexport const createFinalColor = (color: Color, pixels: number): FinalColor => {\n  return {\n    hex: `#${\"0\".repeat(\n      6 - color._hex.toString(16).length\n    )}${color._hex.toString(16)}`,\n    red: color._red,\n    green: color._green,\n    blue: color._blue,\n    area: color._count / pixels,\n    hue: color._hue,\n    saturation: color._saturation,\n    lightness: color._lightness,\n    intensity: color._intensity,\n  };\n};\n"],"names":["Color","constructor","red","green","blue","hex","this","_count","__saturation","__hue","__lightness","__intensity","_red","_green","_blue","_hex","distance","colorA","colorB","Math","abs","clone","color","updateHSL","max","min","_hue","_saturation","_lightness","_intensity","a","b","AverageGroup","colors","_average","addColor","push","isSamePalette","hue","saturation","lightness","currentColor","average","r","g","reduce","total","round","length","AverageManager","_groups","samePalette","find","averageGroup","getGroups","map","LeafGroup","_children","getList","Object","keys","key","createMainColor","main","RootGroup","full","loss","getLeafGroup","getColors","_distance","list","child","sort","newList","current","shift","filter","forEach","near","i","findIndex","splice","extractor","data","width","height","_pixels","_colorValidator","colorGroup","reducer","floor","ignoredColorsCount","count","_sortFinalColors","_colors","_hueDistance","_saturationDistance","_lightnessDistance","averageManager","sorted","sortColors","pixels","repeat","toString","area","intensity","createFinalColor","_extractColorsFromImageBitmap","async","image","cleanOptions","imageData","_image","currentPixels","sqrt","context","OffscreenCanvas","getContext","drawImage","getImageData","_getImageData","j","extractColors","picture","callback","ImageData","_extractColorsFromImageData","src","response","fetch","mode","blob","bitmap","createImageBitmap","close","_extractColorsFromSrc","Error","onmessage","message","_colorValidatorStr","_cleanInputsRest","Function","postMessage"],"mappings":"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"}